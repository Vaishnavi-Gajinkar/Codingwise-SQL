SQL practice questions - Lead, Lag functions 
-------------------------------------------------------------------------------------------------------------------------------------------------
1. Find the previous purchase for each customer using lag
    SELECT *, LAG(product_id, 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date ASC) as prev_purchase FROM customer_purchases 

2. Calculate the difference in purchase amount between current and previous transaction using LAG()
    SELECT *, ((cost_to_customer_per_qty*quantity)-prev_purchase_amt) AS difference 
    FROM (SELECT *, LAG((cost_to_customer_per_qty*quantity), 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS prev_purchase_amt FROM customer_purchases) AS sub

3. Find the next product a customer purchased using Lead
    SELECT *, LEAD(product_id, 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS next_purchased FROM customer_purchases

4. Identify the First purchase and 2nd purchase of each customer using LEAD()
    SELECT customer_id, market_date, product_id AS 1stPurchase, 2ndPurchase FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY customer_id) AS cust_record1 FROM
        (SELECT *, LEAD(product_id, 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS 2ndPurchase FROM customer_purchases cp 
            WHERE market_date=(SELECT MIN(market_date) FROM customer_purchases WHERE customer_id=cp.customer_id)) AS sub) AS sub_sub WHERE cust_record1 = 1

5. Find the purchase date difference between consecutive purchases for each customer
    SELECT customer_id, market_date, next_date, DATEDIFF(market_date, next_date) AS days_since_prev_purchase 
    FROM (SELECT customer_id, market_date, LAG(market_date,1,0) OVER (PARTITION BY customer_id ORDER BY market_date) AS next_date FROM customer_purchases GROUP BY market_date, customer_id) AS sub

6. Compare the current and next booth price for vendors using LEAD()
    SELECT vba.vendor_id, vba.market_date, b.booth_number, b.booth_price_level, LEAD(b.booth_price_level, 1, NULL) OVER (PARTITION BY vba.vendor_id ORDER BY vba.market_date) AS next_booth_price 
    FROM booth b JOIN vendor_booth_assignments vba ON b.booth_number=vba.booth_number

7. Calculate the running total of customer purchases using PARTITION BY
    SELECT customer_id, market_date, (cost_to_customer_per_qty*quantity) AS cost_price, SUM(cost_to_customer_per_qty*quantity) OVER(PARTITION BY customer_id ORDER BY market_date) AS prev_curr_sum FROM customer_purchases

8. Find the previous booth assignment for each vendor
    SELECT *, LAG(booth_number,1,NULL) OVER (PARTITION BY vendor_id ORDER BY market_date) AS previous_booth FROM vendor_booth_assignments

9. Calculate the average cost difference between consecutive purchases
    SELECT customer_id, (cost_to_customer_per_qty*quantity) AS curr_cost, next_cost, ABS((cost_to_customer_per_qty*quantity)-next_cost)/2 AS avg_cost_diff 
    FROM (SELECT *, LEAD((cost_to_customer_per_qty*quantity),1,NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS next_cost FROM customer_purchases) AS sub

10. Identify the next vendor assignment for each booth
    SELECT b.booth_number, vba.vendor_id, vba.market_date, LEAD(vendor_id,1,NULL) OVER (PARTITION BY b.booth_number ORDER BY market_date) AS next_vendor FROM booth b LEFT JOIN vendor_booth_assignments vba ON b.booth_number=vba.booth_number

11. Find the product sold before and after the most popular product
    SELECT vendor_id, prev_qty, qty, next_qty, ROW_NUMBER() OVER (PARTITION BY vendor_id ORDER BY qty DESC) as rn FROM (
        SELECT v.vendor_id AS vendor_id, cp.quantity AS qty, LAG(cp.quantity,1,NULL) OVER (PARTITION BY v.vendor_id ORDER BY cp.quantity DESC) AS prev_qty, LEAD(cp.quantity,1,NULL) OVER (PARTITION BY v.vendor_id ORDER BY cp.quantity DESC) AS next_qty 
        FROM vendor v LEFT JOIN vendor_inventory vi ON v.vendor_id=vi.vendor_id LEFT JOIN customer_purchases cp ON vi.product_id=cp.product_id ORDER BY v.vendor_id) AS sub -- WHERE rn = 1
