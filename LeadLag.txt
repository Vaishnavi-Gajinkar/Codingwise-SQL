SQL practice questions - Lead, Lag functions 
-------------------------------------------------------------------------------------------------------------------------------------------------
1. Find the previous purchase for each customer using lag
    SELECT *, LAG(product_id, 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date ASC) as prev_purchase FROM customer_purchases 

2. Calculate the difference in purchase amount between current and previous transaction using LAG()
    SELECT *, ((cost_to_customer_per_qty*quantity)-prev_purchase_amt) AS difference 
    FROM (SELECT *, LAG((cost_to_customer_per_qty*quantity), 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS prev_purchase_amt FROM customer_purchases) AS sub

3. Find the next product a customer purchased using Lead
    SELECT *, LEAD(product_id, 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS next_purchased FROM customer_purchases

4. Identify the First purchase and 2nd purchase of each customer using LEAD()
    SELECT customer_id, market_date, product_id AS 1stPurchase, 2ndPurchase FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY customer_id) AS cust_record1 FROM
        (SELECT *, LEAD(product_id, 1, NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS 2ndPurchase FROM customer_purchases cp 
            WHERE market_date=(SELECT MIN(market_date) FROM customer_purchases WHERE customer_id=cp.customer_id)) AS sub) AS sub_sub WHERE cust_record1 = 1

5. Find the purchase date difference between consecutive purchases for each customer
    SELECT customer_id, market_date, next_date, DATEDIFF(market_date, next_date) AS days_since_prev_purchase 
    FROM (SELECT customer_id, market_date, LAG(market_date,1,0) OVER (PARTITION BY customer_id ORDER BY market_date) AS next_date FROM customer_purchases GROUP BY market_date, customer_id) AS sub

6. Compare the current and next booth price for vendors using LEAD()
    SELECT vba.vendor_id, vba.market_date, b.booth_number, b.booth_price_level, LEAD(b.booth_price_level, 1, NULL) OVER (PARTITION BY vba.vendor_id ORDER BY vba.market_date) AS next_booth_price 
    FROM booth b JOIN vendor_booth_assignments vba ON b.booth_number=vba.booth_number

7. Calculate the running total of customer purchases using PARTITION BY
    SELECT customer_id, market_date, (cost_to_customer_per_qty*quantity) AS cost_price, SUM(cost_to_customer_per_qty*quantity) OVER(PARTITION BY customer_id ORDER BY market_date) AS prev_curr_sum FROM customer_purchases

8. Find the previous booth assignment for each vendor
    SELECT *, LAG(booth_number,1,NULL) OVER (PARTITION BY vendor_id ORDER BY market_date) AS previous_booth FROM vendor_booth_assignments

9. Calculate the average cost difference between consecutive purchases
    SELECT customer_id, (cost_to_customer_per_qty*quantity) AS curr_cost, next_cost, ABS((cost_to_customer_per_qty*quantity)-next_cost)/2 AS avg_cost_diff 
    FROM (SELECT *, LEAD((cost_to_customer_per_qty*quantity),1,NULL) OVER (PARTITION BY customer_id ORDER BY market_date) AS next_cost FROM customer_purchases) AS sub

10. Identify the next vendor assignment for each booth
    SELECT b.booth_number, vba.vendor_id, vba.market_date, LEAD(vendor_id,1,NULL) OVER (PARTITION BY b.booth_number ORDER BY market_date) AS next_vendor FROM booth b LEFT JOIN vendor_booth_assignments vba ON b.booth_number=vba.booth_number

11. Find the product sold before and after the most popular product
    SELECT vendor_id, prev_qty, qty, next_qty, ROW_NUMBER() OVER (PARTITION BY vendor_id ORDER BY qty DESC) as rn FROM (
        SELECT v.vendor_id AS vendor_id, cp.quantity AS qty, LAG(cp.quantity,1,NULL) OVER (PARTITION BY v.vendor_id ORDER BY cp.quantity DESC) AS prev_qty, LEAD(cp.quantity,1,NULL) OVER (PARTITION BY v.vendor_id ORDER BY cp.quantity DESC) AS next_qty 
        FROM vendor v LEFT JOIN vendor_inventory vi ON v.vendor_id=vi.vendor_id LEFT JOIN customer_purchases cp ON vi.product_id=cp.product_id ORDER BY v.vendor_id) AS sub -- WHERE rn = 1

12. Compare the current and next market_date for each vendor 
    SELECT v.vendor_id, market_date AS curr_date, LEAD(vba.market_date,1,NULL) OVER (PARTITION BY v.vendor_id ORDER BY vba.market_date) AS next_date FROM vendor v LEFT JOIN vendor_booth_assignments vba ON v.vendor_id=vba.vendor_id 

13. Calculate the Lead time between product sales for each vendor 
    SELECT vend_id, cp.product_id, curr_date, DATEDIFF(next_date, curr_date) AS next_sales_after_days FROM 
        (SELECT v.vendor_id AS vend_id, cp.market_date AS curr_date, LEAD(cp.market_date,1,NULL) OVER (PARTITION BY v.vendor_id ORDER BY cp.market_date) AS next_date 
            FROM vendor v LEFT JOIN vendor_inventory vi ON v.vendor_id=vi.vendor_id LEFT JOIN customer_purchases cp ON vi.market_date=cp.market_date) AS sub

14. Compare the current and previous inventory update date for vendors
    SELECT *, DATEDIFF(current_market_date, prev_updated_on) AS days_updated_after FROM
        (SELECT DISTINCT vendor_id, current_market_date, prev_updated_on FROM
            (SELECT vendor_id, LEAD(market_date, 1, NULL) OVER (PARTITION BY vendor_id ORDER BY market_date) AS current_market_date, market_date AS prev_updated_on FROM vendor_inventory) AS sub_sub GROUP BY current_market_date, prev_updated_on, vendor_id) AS sub

15. Identify vendors with the shortest lead time between sales
    SELECT * FROM
        (SELECT *, MIN(trxn_time_diff) OVER (PARTITION BY market_date) AS mini_trxn_time_this_day FROM 
            (SELECT *, TIMEDIFF(LEAD(transaction_time) OVER (PARTITION BY vendor_id, market_date ORDER BY market_date, transaction_time), transaction_time) AS trxn_time_diff FROM customer_purchases) AS sub_sub) AS sub WHERE mini_trxn_time_this_day = trxn_time_diff

16. Find the previous purchase date for each customer
    SELECT c.customer_id, CONCAT(c.customer_first_name," ",c.customer_last_name) AS cust_full_name, cp.product_id, market_date AS purchase_dt, LAG(market_date,1,"First Purchase") OVER (PARTITION BY c.customer_id ORDER BY market_date) AS prev_purchase_date 
    FROM customer_purchases cp JOIN customer c ON cp.customer_id=c.customer_id
    
17. Compare the current and next product price for each vendor
    SELECT * FROM 
        (SELECT v.vendor_id, v.vendor_name, vi.product_id, market_date, original_price, ROUND(LEAD(original_price) OVER (PARTITION BY v.vendor_id ORDER BY vi.market_date),2) AS next_price 
         FROM vendor v LEFT JOIN vendor_inventory vi ON v.vendor_id=vi.vendor_id) AS sub 
    WHERE original_price != next_price

18. Calculate the lead time between vendor booth assignments
    SELECT *, DATEDIFF(next_booth_assgn_on, market_date) AS day_interval, TIMEDIFF(next_booth_assgn_on, market_date) AS time_interval FROM
        (SELECT *, LEAD(market_date,1,NULL) OVER (PARTITION BY vendor_id ORDER BY market_date) AS next_booth_assgn_on FROM vendor_booth_assignments) AS sub

19. Find the previous and next booth assignment for each vendor
    SELECT vendor_id, market_date, 
    LAG(booth_number,1,"first_booth_assigned") OVER (PARTITION BY vendor_id ORDER BY market_date) AS prev_booth, booth_number AS curr_booth, 
    LEAD(booth_number,1,"last_assigned_booth") OVER (PARTITION BY vendor_id ORDER BY market_date) AS next_booth 
    FROM vendor_booth_assignments ORDER BY vendor_id, market_date

20. Identify vendors who changed booths between consecutive market dates
    SELECT vendor_id, booth_number, next_booth_num, market_date,next_booth_assgn_on FROM
        (SELECT *, (booth_number - next_booth_num) AS same_booth_check, DATEDIFF(next_booth_assgn_on, market_date) AS day_interval FROM
            (SELECT *, LEAD(market_date,1,NULL) OVER (PARTITION BY vendor_id ORDER BY market_date) AS next_booth_assgn_on, LEAD(booth_number,1,NULL) OVER (PARTITION BY vendor_id ORDER BY market_date) AS next_booth_num
             FROM vendor_booth_assignments) AS sub_sub) AS sub WHERE day_interval = 1 AND same_booth_check != 0

21. Calculate the sales difference between consecutive transactions
    SELECT market_date, quantity*cost_to_customer_per_qty AS curr_txn_cost, next_txn_cost, ABS((cost_to_customer_per_qty*quantity)-next_txn_cost) AS sales_difference FROM
    (SELECT *, LEAD(quantity*cost_to_customer_per_qty,1,"last_transaction_of_day") OVER (PARTITION BY market_date ORDER BY transaction_time) AS next_txn_cost FROM customer_purchases) AS sub

22. Find the 1st & 2nd most sold products for each vendor
    SELECT * FROM (
        SELECT v.vendor_id, cp.quantity, ROW_NUMBER() OVER (PARTITION BY v.vendor_id ORDER BY cp.quantity DESC) AS roenum 
        FROM customer_purchases cp RIGHT JOIN vendor_inventory vi ON cp.vendor_id=vi.vendor_id RIGHT JOIN vendor v ON vi.vendor_id=v.vendor_id) AS sub WHERE roenum IN (1,2)

23. Compare the current and previous total revenue for each vendor 
    SELECT *, CASE WHEN todays_revnu > next_day_revnu THEN "Better than next day"
               WHEN todays_revnu < next_day_revnu THEN "next day was Better"
               ELSE "Same as yesterday" END AS daily_market_perf FROM (
    SELECT *, (quantity*cost_to_customer_per_qty) AS todays_revnu, LEAD((quantity*cost_to_customer_per_qty),1,NULL) OVER (PARTITION BY vendor_id ORDER BY market_date) as next_day_revnu FROM customer_purchases) AS sub

24. Display the running total of products sold by each vendor

25. Identify customers who increased their purchase quantity over consecutive transactions 

26. Calculate the difference in booth prices between consecutive assignment for vendors

27. Find vendors with the highest and lowest sales for consecutive market dates