## CS1 - Operations wants to see how much revenue each vendor made on each market day to plan booth pricing.
Approach: Compute daily gross revenue per vendor (quantity × cost_to_customer_per_qty) for all market dates

    WITH gros_rev AS (
        SELECT vi.vendor_id, cp.market_date, (cp.quantity*cp.cost_to_customer_per_qty) AS revenue FROM vendor_inventory vi JOIN customer_purchases cp WHERE cp.vendor_id=vi.vendor_id
        )
    SELECT vendor_id, market_date, SUM(revenue) AS total FROM gros_rev GROUP BY vendor_id, market_date ORDER BY vendor_id, market_date

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS2 - Category managers want a weekly leaderboard of products by total quantity sold.
For each (market_year, market_week), list the top 3 products by total quantity sold.

    WITH qty_sold AS (
        SELECT mdi.market_year, mdi.market_week, p.product_id, cp.quantity 
        FROM product p JOIN customer_purchases cp ON p.product_id=cp.product_id 
                    JOIN market_date_info mdi on cp.market_date=mdi.market_date
    )
    SELECT * FROM (
    SELECT *, RANK() OVER(PARTITION BY market_year ORDER BY tot_qty_sold DESC) AS rnk FROM(
    SELECT market_year, market_week, product_id, SUM(quantity) AS tot_qty_sold FROM qty_sold
    GROUP BY mdi.market_year, mdi.market_week, p.product_id ORDER BY market_year, market_week, product_id) AS sub_sub) AS sub WHERE rnk < 4

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS3 - Marketing wants to understand seasonal behavior (e.g., “Summer” vs “Fall”).
Compute average quantity purchased per transaction per customer per season.

    WITH qty_per_szn AS (
        SELECT cp.customer_id, mdi.market_season, AVG(cp.quantity) 
        FROM market_date_info mdi JOIN customer_purchases cp ON cp.market_date=mdi.market_date 
        GROUP BY cp.customer_id, mdi.market_season
        ORDER BY cp.customer_id, mdi.market_season
        )
    SELECT * FROM qty_per_szn

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS4 - To optimize staffing, ops wants to split sales into morning (≤12:00) vs afternoon (>12:00)
For each day, compute morning revenue vs afternoon revenue

    WITH tod AS (
    SELECT *, CASE WHEN transaction_time < '12:00:00' THEN 'morning'
                WHEN transaction_time > '17:00:00' THEN 'evening'
                ELSE 'afternoon' END AS 'prahar'
    FROM customer_purchases 
    )

    SELECT market_date, prahar, SUM(quantity*cost_to_customer_per_qty) AS revenue FROM tod
    GROUP BY market_date, prahar
    ORDER BY market_date,
        CASE prahar WHEN 'morning' THEN 1
                    WHEN 'afternoon' THEN 2
                    WHEN 'evening' THEN 3
                END ASC

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS5 - Finance wants to evaluate discounts: compare actual selling price vs the vendor’s listed price.
For each (vendor_id, product_id, market_date), compute the average selling price, listed price, and variance.

myqry - with discount_var AS(
            select cp.market_date, cp.vendor_id, cp.product_id, cp.quantity as qty, cp.cost_to_customer_per_qty as ctcpqty, vi.original_price as org_prc from customer_purchases cp JOIN vendor_inventory vi ON cp.product_id=vi.product_id
            )
            select *, (org_prc - avg_cost) as variance from(select market_date, vendor_id, product_id, AVG(qty*ctcpqty) as avg_cost, org_prc from discount_var group by market_date, vendor_id, product_id, org_prc) as sub

WITH avg_sell AS (
    SELECT vendor_id, product_id, market_date, AVG(cost_to_customer_per_qty) AS avg_selling_price FROM customer_purchases GROUP BY vendor_id, product_id, market_date
    )
    SELECT a.vendor_id, a.product_id, a.market_date, a.avg_selling_price, vi.original_price AS listed_price, (a.avg_selling_price - vi.original_price) AS price_variance
    FROM avg_sell a JOIN vendor_inventory vi ON vi.vendor_id = a.vendor_id
    AND vi.product_id = a.product_id   AND vi.market_date = a.market_date
    ORDER BY a.market_date, a.vendor_id, a.product_id;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS6 - Data team noticed inconsistent entries for product size and wants a report.
List products where product_size is NULL or blank

SELECT * FROM product WHERE product_size IS NULL OR TRIM(product_size) LIKE ""

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS7 - Management wants to know which customers are willing to pay more than average.
Find purchases where the transaction price was above the product’s average.

WITH prod_avg_prc AS(
    SELECT product_id, AVG(cost_to_customer_per_qty) AS product_avg FROM customer_purchases GROUP BY product_id
)
SELECT DISTINCT cp.product_id, customer_id, cost_to_customer_per_qty as paid_prc, product_avg FROM customer_purchases cp JOIN prod_avg_prc pag ON cp.product_id=pag.product_id
WHERE pag.product_avg < cost_to_customer_per_qty
ORDER BY cp.product_id, customer_id, product_avg

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS8 - Find each vendor’s second-best day
Return day with second-highest revenue for each vendor.

Approach 1 -

WITH 2ndbest AS(
    SELECT vendor_id, tot, RANK() OVER(PARTITION BY vendor_id ORDER BY tot DESC) AS rnk FROM (
        SELECT vendor_id, market_date, SUM(quantity*cost_to_customer_per_qty) AS tot FROM customer_purchases GROUP BY  vendor_id, market_date) AS sub
)
SELECT * FROM 2ndbest WHERE rnk=2

---------------------------
Approach 2 -

SELECT vendor_id, MAX(quantity*cost_to_customer_per_qty) as tot FROM customer_purchases 
WHERE tot < (SELECT vendor_id, MAX(quantity*cost_to_customer_per_qty) FROM customer_purchases GROUP BY vendor_id)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS9 - Marketing wants to segment customers into quartiles by total spend.
Compute total spend per customer and split into quartiles

WITH cte AS (
    SELECT customer_id, SUM(quantity*cost_to_customer_per_qty) AS tot_spend FROM customer_purchases
    GROUP BY customer_id
)
SELECT *, NTILE(4) OVER(ORDER BY tot_spend DESC) AS PERCENTILE FROM cte

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS10 - Finance wants cumulative weekly revenue per vendor by year.
Compute cumulative revenue by vendor by week

WITH cte AS(
    SELECT market_year, market_week, cp.vendor_id, SUM(cp.quantity*cost_to_customer_per_qty) AS spend
    FROM market_date_info mdi JOIN customer_purchases cp ON mdi.market_date=cp.market_date
    GROUP BY market_year, market_week, cp.vendor_id 
    ORDER BY market_year, market_week 
)
SELECT market_year, market_week, vendor_id, spend, SUM(spend) OVER(PARTITION BY vendor_id BY market_week, market_year) AS cum_sum FROM cte 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS11 - Merchandising wants a rolling view over last 3 markets per vendor.
Compute 3-row rolling sum of revenue.

WITH cte AS (
    SELECT *, (quantity*cost_to_customer_per_qty) AS revenue FROM customer_purchases
)
SELECT vendor_id, market_date, revenue, SUM(revenue) OVER(PARTITION BY vendor_id ORDER BY market_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_sum FROM cte
ORDER BY vendor_id, market_date

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CS12 - Ops wants sales split into rain vs no-rain columns
Show daily revenue split into rain_revenue and no_rain_revenue.

with rainy AS(
    SELECT mdi1.market_date, SUM(quantity*cost_to_customer_per_qty) AS rain_rev
    FROM customer_purchases cp JOIN market_date_info mdi1 USING(market_date) JOIN market_date_info mdi2 USING(market_date)
    WHERE mdi1.market_date = mdi2.market_date AND mdi1.market_rain_flag = 1
    GROUP BY market_date ORDER BY market_date),
nonrainy AS(
    SELECT mdi1.market_date, SUM(quantity*cost_to_customer_per_qty) AS non_rain_rev
    FROM customer_purchases cp JOIN market_date_info mdi1 USING(market_date) JOIN market_date_info mdi2 USING(market_date)
    WHERE mdi1.market_date = mdi2.market_date AND mdi1.market_rain_flag = 0
    GROUP BY market_date ORDER BY market_date)

SELECT market_date, rain_rev, NULL AS "non_rain_rev" from rainy
UNION
SELECT market_date, NULL AS "rain_rev", non_rain_rev from nonrainy
GROUP BY market_date 
ORDER BY market_date

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
